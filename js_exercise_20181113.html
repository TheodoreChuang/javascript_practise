<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
<script>
    
// Javascript Challenges

// Challenge 1
// Make a terminal script that will create a journal with a short-term memory. Weird, I know.
// Prompt a user for any content. What they did yesterday, what their favourite colour is, whatever. Store the user input in an array.
// Print out all entries in the array.
// Loop back and prompt the user for the next journal entry.
// The journal can only contain a maximum of 5 entries, but can loop forever.

// let input = undefined;
// let arr_foods = [];
// do {
//   input = prompt("What are your favorite foods?");
//   if (arr_foods.length > 4) {
//     arr_foods = arr_foods.slice(1);
//   }
//   arr_foods.push(input);
//   console.log(arr_foods);
// } while (input.toLowerCase() !== "exit");

// Challenge 2
// Atomic Blonde Number:
// a number is an atomic blonde number if the sum and product of its digits are equal.
// For example, 123 is an atomic blonde number, as the sum of its digits (1+2+3) is 6, which is equal to the product of its digits (1*2*3).
// Write a program to check if a number is an atomic blonde number or not.

function isAtomicBlondeNumber(num) {
  let ints = num.toString().split("");
  let sum = ints.reduce((acc, curr) => parseInt(acc) + parseInt(curr));
  let products = ints.reduce((acc, curr) => parseInt(acc) * parseInt(curr));
  return sum === products;
}
// isAtomicBlondeNumber(123);

// Challenge 3
// Pick any four digit number and do the following:
// Rearrange the string of digits to form the largest and smallest 4-digit numbers possible.
// Take these two numbers and subtract the smaller number from the larger.
// Suppose we choose the number 8082.
// 8820−0288=8532
// 8532−2358=6174
// 7641−1467=6174
// It hits 6174 and then stops.
// Count also how many iterations loops are required to get to this point.
// Bonus points for recognising what 6174 is.

// Kaprekar's Constant: 6174
function kaprekarDiff(num) {
  let ints = num
    .toString()
    .split("")
    .map(str => parseInt(str));
  bigNum = parseInt(ints.sort((a, b) => b - a).join(""));
  smallNum = parseInt(ints.sort((a, b) => a - b).join(""));
  diff = bigNum - smallNum;
  return diff;
}

function kaprekarLoop(num) {
  let diff = num;
  let previousDiff = 0;
  let counter = 0;
  do {
    previousDiff = diff; // assigns previous diff
    diff = kaprekarDiff(diff); // calc new diff
    counter++;
  } while (diff !== previousDiff);
  return counter;
}
// kaprekarLoop(8082)  // => 3
// kaprekarLoop(3141)  // => 6

// 2018-11-14 Morning Challenge
// 1. Implement topWatchlistedMoviesAmongFriends method that will return an array of top four movie titles, that have been most watchlisted by friends of a given user.
// 2. If there are no such movies, then an empty list should be returned or as many movies as possible.
// 3. Movies that have equal watchlist count, should be ordered alphabetically.
let movies = [
  {
    title: "The Shawshank Redemption",
    duration: "PT142M",
    actors: ["Tim Robbins", "Morgan Freeman", "Bob Gunton"],
    ratings: [],
    watchlist: [15291, 51417, 62289, 6146, 71389, 93707]
  },
  {
    title: "The Godfather",
    duration: "PT175M",
    actors: ["Marlon Brando", "Al Pacino", "James Caan"],
    ratings: [],
    watchlist: [62289, 66380, 34139, 6146]
  },
  {
    title: "The Dark Knight",
    duration: "PT152M",
    actors: ["Christian Bale", "Heath Ledger", "Aaron Eckhart"],
    ratings: [],
    watchlist: [51417, 62289, 6146, 71389, 7001]
  },
  {
    title: "Pulp Fiction",
    duration: "PT154M",
    actors: ["John Travolta", "Uma Thurman", "Samuel L. Jackson"],
    ratings: [],
    watchlist: [7001, 9250, 34139, 6146]
  },
  {
    title: "Schindler's List",
    duration: "PT195M",
    actors: ["Liam Neeson", "Ralph Fiennes", "Ben Kingsley"],
    watchlist: [15291, 51417, 7001, 9250, 93707]
  }
];
let users = [
  {
    userId: 15291,
    email: "Constantin_Kuhlman15@yahoo.com",
    friends: [7001, 51417, 62289]
  },
  {
    userId: 7001,
    email: "Keven6@gmail.com",
    friends: [15291, 51417, 62289, 66380]
  },
  {
    userId: 51417,
    email: "Margaretta82@gmail.com",
    friends: [15291, 7001, 9250]
  },
  {
    userId: 62289,
    email: "Marquise.Borer@hotmail.com",
    friends: [15291, 7001]
  }
];
// Your implementation should return following output for userId=62289 for example data:
// ["Schindler's List", "Pulp Fiction", "The Dark Knight", "The Shawshank Redemption"]
// In the example above, user with id 62289 has two friends: user with id=15291and with id=7001. Schindler's List is watchlisted by both users, so it will be the most watchlisted.

// 1. Implement topWatchlistedMoviesAmongFriends method that will return an array of top four movie titles, that have been most watchlisted by friends of a given user.
// 2. If there are no such movies, then an empty list should be returned or as many movies as possible.
// 3. Movies that have equal watchlist count, should be ordered alphabetically.

function topWatchlistedMoviesAmongFriends(userId) {
  // get user
  let user = null;
  users.forEach(function(useri){
    if(useri["userId"] === userId) {
      user = useri;
    } 
  });
  // get user's friends
  let friends = user.friends;
  // for each movie, check if friend is on watchlist
  let watchlistMovies = [];

  let friend = 7001;
  movies.forEach(function(movie) {
    movie.watchlist // array

  });
  // for each friend, iterate through movies list and grab their movies
  // tally count for every unique movie
  // sort most watchlist, if tie order alphabetically
}
topWatchlistedMoviesAmongFriends(62289)

</script>
</body>
</html>